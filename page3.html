<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Archive Media Filter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>
    body {
      font-family: system-ui, monospace;
      background: #020617;
      color: #e5e7eb;
      padding: 2rem;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    h2 { margin-bottom: 0.5rem; }
    #status { color: #94a3b8; margin-bottom: 1rem; }

    #log {
      flex: 1;
      border: 1px solid #334155;
      padding: 1rem;
      overflow-y: auto;
      white-space: pre-wrap;
      font-size: 0.85rem;
    }
  </style>
</head>
<body>

<h2>Filtering Media Items‚Ä¶</h2>
<div id="status"></div>
<div id="log"></div>

<script>
/* ---------------------------------- */
/* Utilities                          */
/* ---------------------------------- */

const logBox = document.getElementById("log");
const statusBox = document.getElementById("status");

const log = msg => {
  logBox.textContent += msg + "\n";
  logBox.scrollTop = logBox.scrollHeight;
};

/* ---------------------------------- */
/* Load identifiers                   */
/* ---------------------------------- */

const stored = sessionStorage.getItem("archive_items");
if (!stored) {
  alert("No items found. Start from page2.html");
  throw new Error("Missing archive_items");
}

const data = JSON.parse(stored);
const items = data.items || [];

statusBox.textContent = `Total identifiers received: ${items.length}`;

/* ---------------------------------- */
/* Archive official media detection   */
/* ---------------------------------- */

function detectMediaFromArchive(meta) {
  const types = new Set();

  const archiveType = meta.metadata?.mediatype;

  switch (archiveType) {
    case "movies": types.add("movie"); break;
    case "audio":  types.add("audio"); break;
    case "texts":  types.add("text");  break;
    case "image":  types.add("image"); break;
  }

  for (const f of meta.files || []) {
    const format = (f.format || "").toLowerCase();

    if (format.includes("mp4") || format.includes("mpeg") || format.includes("matroska"))
      types.add("movie");

    if (format.includes("mp3") || format.includes("flac") || format.includes("ogg") || format.includes("wav"))
      types.add("audio");

    if (format.includes("pdf") || format.includes("text") || format.includes("epub"))
      types.add("text");

    if (format.includes("jpeg") || format.includes("png") || format.includes("image"))
      types.add("image");
  }

  return [...types];
}

/* ---------------------------------- */
/* Fetch metadata                     */
/* ---------------------------------- */

async function fetchMetadata(identifier) {
  const res = await fetch(`https://archive.org/metadata/${identifier}`);
  if (!res.ok) throw new Error("Metadata fetch failed");
  return res.json();
}

/* ---------------------------------- */
/* Main execution (5 at a time)        */
/* ---------------------------------- */

(async () => {
  const processedItems = [];
  const CONCURRENCY = 5;
  let index = 0;

  async function worker() {
    while (index < items.length) {
      const current = items[index++];
      try {
        const meta = await fetchMetadata(current.identifier);
        const types = detectMediaFromArchive(meta);

        processedItems.push({
          identifier: current.identifier,
          owner: current.owner,
          types
        });

        log(`‚úî ${current.identifier} ‚Üí ${types.join(", ") || "none"}`);
      } catch {
        log(`‚ö† ${current.identifier} ‚Üí error`);
      }
    }
  }

  const workers = Array.from({ length: CONCURRENCY }, worker);
  await Promise.all(workers);

  statusBox.textContent = "Filtering complete. Waiting for selection‚Ä¶";

  /* üîî Tell index.html to show options */
  window.parent.postMessage(
    { type: "SELECT_A_OPTION" },
    "*"
  );

  /* ---------------------------------- */
  /* Receive option from index.html     */
  /* ---------------------------------- */

  window.addEventListener("message", (event) => {
    if (event.data?.type !== "OPTION_SELECTED") return;

    const option = event.data.option;
    let targetPage = "";
    let payload = [];

    switch (option) {
      case "REALM":
        payload = processedItems;
        targetPage = "page4.html";
        break;

      case "ARC":
        payload = processedItems.filter(i => i.types.includes("movie"));
        targetPage = "page5.html";
        break;

      case "FLASH":
        payload = processedItems.filter(i => i.types.includes("image"));
        targetPage = "page6.html";
        break;

      case "VERSE":
        payload = processedItems.filter(i => i.types.includes("text"));
        targetPage = "page7.html";
        break;

      case "CATCHY":
        payload = processedItems.filter(i => i.types.includes("audio"));
        targetPage = "page8.html";
        break;

      default:
        log("‚ùå Unknown option received");
        return;
    }

    sessionStorage.setItem(
      "archive_final_items",
      JSON.stringify({
        option,
        total: payload.length,
        items: payload
      })
    );

    log(`\n‚û° Final page decided: ${targetPage}`);
    log(`üì¶ Items passed: ${payload.length}`);

    window.parent.postMessage(
      { type: "FINAL_PAGE_READY", page: targetPage },
      "*"
    );
  });

})();
</script>

</body>
</html>
